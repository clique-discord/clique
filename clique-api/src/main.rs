//! A relatively simple API server for exploring the data collected by Clique.
//!
//! # Configuration
//!
//! The server reads configuration from a TOML file at `config.toml`. The following fields are
//! required:
//! - `postgres_url`: The URL of the Postgres database to connect to.
//! - `address`: The address to bind the server to.
//! - `port`: The port to bind the server to.
//!
//! # Endpoints
//!
//! All endpoints can return either JSON or MessagePack, depending on the `Accept` header. If the
//! `Accept` header indicates support for the `application/msgpack` MIME type, MessagePack will be
//! returned. Otherwise, JSON will be used.
//!
//! ## `/`
//!
//! Returns an object with a single field, `version`, which is the version of the API server.
//!
//! ## `/points`
//!
//! Gives the number of times each pair of users spoke to each other, grouped by a given time period
//! and optionally filtered by a guild ID and start and end dates.
//!
//! Query parameters:
//! - `period`: One of `microsecond`, `millisecond`, `second`, `minute`, `hour`, `day`, `week`,
//!   `month`, `quarter`, `year`, `decade`, `century`, `millennium`. Required.
//! - `guild`: The ID of a guild to filter by. Optional.
//! - `after`: The start of the time period to filter by. Optional.
//! - `before`: The end of the time period to filter by. Optional.
//!
//! `after` and `before` should be in RFC 3339 format (a subset of ISO 8601 that looks like
//! `2020-01-01T00:00:00Z`).
//!
//! The response is an array of objects, each of which has the following fields:
//! - `start`: The start of the time period, in RFC 3339 format.
//! - `pairs`: An array of objects, each of which has the following fields:
//!     - `user1`: The ID of the first user in the pair.
//!     - `user2`: The ID of the second user in the pair.
//!     - `points`: The number of times the pair spoke to each other during the time period.
//!
//! ## `/user/<id>`
//!
//! Gets a user's name by their Discord ID. The response is an object with the following fields:
//! - `id`: The user's Discord ID.
//! - `name`: The user's name.
//!
//! # Errors
//!
//! Errors will be returned as objects with the following fields:
//! - `code`: A short string identifying the type of error.
//! - `message`: A human-readable description of the error.
//!
//! As with all responses, errors can be returned as either JSON or MessagePack, depending on the
//! `Accept` header. Error responses will also be sent with an appropriate HTTP status code.
#![warn(clippy::all, clippy::pedantic, clippy::nursery, missing_docs)]
// Seems to be generated by Rocket.
#![allow(clippy::no_effect_underscore_binding)]
// False positives - thinks MessagePack is an item.
#![allow(clippy::doc_markdown)]

use clique_db::{Database, GetPoints, PeriodData};
use response::{Error, Object, Response};
use rocket::{form::FromFormField, get, http::Status, launch, routes};
use serde::Serialize;

mod response;

#[derive(Serialize)]
struct Index {
    version: &'static str,
}

#[get("/")]
const fn index() -> Object<Index> {
    Object(Index {
        version: env!("CARGO_PKG_VERSION"),
    })
}

#[derive(FromFormField)]
enum TimePeriod {
    Hour,
    Day,
    Week,
    Month,
}

impl From<TimePeriod> for clique_db::TimePeriod {
    fn from(period: TimePeriod) -> Self {
        match period {
            TimePeriod::Hour => Self::Hour,
            TimePeriod::Day => Self::Day,
            TimePeriod::Week => Self::Week,
            TimePeriod::Month => Self::Month,
        }
    }
}

struct DateTime(clique_db::DateTime);

impl<'v> FromFormField<'v> for DateTime {
    fn from_value(value: rocket::form::ValueField<'v>) -> rocket::form::Result<'v, Self> {
        let datetime = chrono::DateTime::<chrono::FixedOffset>::parse_from_rfc3339(value.value)
            .map_err(|_| rocket::form::Error::validation("Invalid RFC 3339 date."))?
            .with_timezone(&chrono::Utc);
        Ok(Self(datetime))
    }
}

#[get("/points?<period>&<guild>&<after>&<before>")]
async fn points(
    db: &rocket::State<Database>,
    period: TimePeriod,
    guild: Option<u64>,
    after: Option<DateTime>,
    before: Option<DateTime>,
) -> Response<Vec<PeriodData>> {
    let points = GetPoints {
        period: period.into(),
        guild,
        after: after.map(|DateTime(d)| d),
        before: before.map(|DateTime(d)| d),
    }
    .run(db)
    .await?;
    Ok(Object(points))
}

#[derive(serde::Serialize)]
struct User {
    id: u64,
    name: String,
}

#[get("/user/<id>")]
async fn user(db: &rocket::State<Database>, id: u64) -> Response<User> {
    db.get_user(id).await?.map_or_else(
        || {
            Err(Error::new(
                "not_found",
                format!("No user found by ID {id}."),
                Status::NotFound,
            ))
        },
        |name| Ok(Object(User { id, name })),
    )
}

#[derive(serde::Deserialize)]
struct Config {
    postgres_url: String,
    address: std::net::IpAddr,
    port: u16,
}

#[launch]
async fn rocket() -> _ {
    let config: Config = toml::from_str(&std::fs::read_to_string("config.toml").unwrap()).unwrap();
    let rocket_config = rocket::config::Config {
        address: config.address,
        port: config.port,
        ..Default::default()
    };
    let db = Database::new(&config.postgres_url).await.unwrap();
    rocket::custom(rocket_config)
        .manage(db)
        .mount("/", routes![index, points, user])
}
